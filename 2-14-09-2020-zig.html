<h1>zig</h1>
<a href="../blog">blog</a>
<p>I've been playing around with <a href="https://ziglang.org/">zig</a> after admiring it for a while.</p>
<p>I had been learning ARM 64 bit assembly (v8 primarily, but pragmatically using a v7 subset...). most people find learning an assembly language humbling, I felt like I'd been pretending I was a programmer up until that point because I was making such basic architectural mistakes as exposed by the bugs I was seeing in my code.</p>
<p>talking to other programmers (ones who are definitely more accomplished and skilled than I) about this situation led to a retrospectively simple insight. one the reason we still use programming languages, even when we need the kind of fine grained control assembly offers, is that everyone who goes from programming using a language to directly using instructions for the processor makes the sort of mistakes I'm making. we write code with guard rails, never hit the guard rails, and fantasize that we could easily write code for unknown terrain where the guard rails aren't even there, by imagining the guard rails</p>
<p>to tail call the metaphor, of course the imagined guard rails are missing one thing the real guard rails had: the architectural work of figuring out where they belong.</p>
<p>so after some research and contemplation, I think that, if I really want to use assembly (if that wasn't itself a mistake), but I want someone else to decide in the abstract case where the guard rails would go, zig is a really great start. better than c. better than rust.</p>
<p>why better than c? I'll let the zig website linked above speak on that, it's more qualified, and that's the main topic of the site. it's the implicit existential question. if c is better, zig has proclaimed it has no reason to exist. zig explicitly only exists as better c.</p>
<p>why better than rust? as a glib metaphor, rust does to c++ what zig does to c. I think I borrowed that metaphor from the zig author? I don't have the citation handy. anyway regardless of the source, it feels right. rust tries to have features and models that extend our architectural imagination. each one is a strictly opt-in bargain where you can choose to do without it, but some are harder to opt out of then others because other features we want build on them. it's well curated but accretive and layered. and as any c++, scala, or lisp programmer knows, when you have a language with optional features, and you use libraries, or have collaborators, you live with other people's chosen features.</p>
<p>zig uses a small set of features in a brutally internally consistent manner, so that none of them impose a cost your code might not afford.</p>
<p>as an illustrative example, "code modules" or "namespaces" (I forget what zig calls them, this is what other languages call them) are implemented using the same language featureset that implements structs. to do "OO" you can instantiate a struct and override fields. this means we have ML style functors as modules: you can instantiate a code module and specialize public values as fields. this reveals that the author is either clever enough to realize how simple advanced namespacing and best in class module definition can be, or that this implementation decision is natural, and the only possible consequence of using the simplest rules in a gruesomely, truly scarily consistent manner. experts in lisp derived languages might feel a deep biological ESP tingling, some sense that something very good and very familiar is present here. or at least I present myself to other lisp experts as an expert, and they haven't called my bluff recently, and I think I see something very exciting.</p>
<p>tail calling that excitement, my exploration of zig follows from that hint of what might be a realization. now I am doing the work to see if it lives up to it, because my hunches can be hilariously wrong but I like this one enough to follow it up in public. a good blog isn't a hindsight fable, it's a tale told as the action flows around you, so here we go!</p>
